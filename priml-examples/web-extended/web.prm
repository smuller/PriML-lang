extern type socket_domain
extern type socket_type
extern type socket_bool_option
extern type inet_addr
extern type file_descr
extern type sockaddr
extern type msg_flag
extern type bytes
extern type tm
extern type shutdown_command
extern type access_permission
extern type in_channel
extern val Unix.socket : (socket_domain -> socket_type -> int -> file_descr)
extern val Unix.PF_INET : socket_domain
extern val Unix.SOCK_STREAM : socket_type
extern val Unix.setsockopt : file_descr -> socket_bool_option -> bool -> unit
extern val Unix.SO_REUSEADDR : socket_bool_option
extern val Unix.ADDR_INET : inet_addr * int -> sockaddr
extern val Unix.inet_addr_loopback : inet_addr
extern val Unix.accept : file_descr -> file_descr * sockaddr
extern val Unix.bind : file_descr -> sockaddr -> unit
extern val Unix.listen : file_descr -> int -> unit
extern val Unix.send_substring : file_descr -> (string -> (int -> (int -> int)))
extern val Unix.recv : file_descr -> (bytes -> (int -> (int -> ((msg_flag list) -> int))))
extern val String.split_on_char : char -> string -> string list
extern val Bytes.create : int -> bytes
extern val Bytes.sub : bytes -> int -> int -> bytes
extern val Bytes.to_string : bytes -> string
extern val Unix.localtime : int -> tm
extern val Unix.shutdown : file_descr -> shutdown_command -> unit
extern val Unix.SHUTDOWN_ALL : shutdown_command
extern val Unix.R_OK : access_permission
extern val Unix.access : string -> (access_permission list) -> unit

extern val at_exit : (unit -> unit) -> unit

extern val 'a List.nth : 'a list -> int -> 'a
extern val 'a List.app : ('a -> unit) -> 'a list -> unit
extern val 'a List.length : 'a list -> int

extern val ^ : string * string -> string
extern val string_of_int : int -> string
extern val String.length : string -> int

exception Invalid_argument of string
					   
priority low_hash_p
priority accept_p
priority high_hash_p
priority serve_p

order low_hash_p < accept_p
order accept_p < high_hash_p
order high_hash_p < serve_p

type stat = {page : string,
             views : int}

val sock =
    ((Unix.socket Unix.PF_INET) Unix.SOCK_STREAM) 0

val _ =
    (Unix.setsockopt sock Unix.SO_REUSEADDR true;
     Unix.bind sock (Unix.ADDR_INET (Unix.inet_addr_loopback, 8000));
     Unix.listen sock 32)

fun accept sock =
    let val (s, _) = Unix.accept sock in s end

fun close sock = (Unix.shutdown sock) Unix.SHUTDOWN_ALL

  
val socks = ref ((fn () => close sock)::nil)

fun addtosocks s =
    socks := (fn () => close s)::(!socks)

val _ = at_exit (fn () => List.app (fn f => f ()) (!socks))

	(*

val reqbuf = ref nil
val stats = ref nil

(* Sequential base case for fib *)
fun seqfib n =
    if le (n, 1) then 1
    else let val (r1, r2) = (seqfib (minus (n, 1)), seqfib (minus (n, 2)))
         in plus (r1, r2)
         end

(* Priority-polymorphic parallel fib *)
fun[w] fib n =
         let fun fib_int n : int cmd[w] =
                 if le (n, 1) then cmd[w] {ret 1}
                 else if le (n, 20) then cmd[w] {ret (seqfib n)}
                 else
                     cmd[w]
                        { bt <- spawn[w] { fib_int (minus (n, 1)) };
                          a <- fib_int (minus (n, 2));
                          b <- sync bt;
                          plus (a, b)}
         in
             cmd[w]
             {
               f <- fib_int n;
               print (cat (Int.toString f, "\n"))
             }
         end

fun statloop () =
    let fun update_stats (r, ss) =
            if List.exists (fn {page, views} => eq (page, r)) ss then
                List.map (fn {page, views} =>
                             if eq (page, r) then
                                 {page = page, views = plus (views, 1)}
                             else
                                 {page = page, views = views})
                     ss
            else
                cons ({page = r, views = 1}, ss)
        fun comp_stats rs ss =
            List.foldl update_stats ss rs
        val reqs = !reqbuf
        val stats' = comp_stats reqs nil
    in
        upd (stats, stats');
        cmd[stat_p]
           { ret ([stat_p]fib 42);
             statloop ()
           }
    end
	 *)

fun parse_request s =
    let val tokens = String.split_on_char ?  s
	val url = List.nth tokens 1
	val urltokens = String.split_on_char ?/ url
    in
	SOME (List.nth urltokens (List.length urltokens - 1))
    end

type tm = {
  tm_sec : int,
  tm_min : int,
  tm_hour : int,
  tm_mday : int,
  tm_mon : int,
  tm_year : int,
  tm_wday : int,
  tm_yday : int,
  tm_isdst : bool
}

extern type float
extern val Unix.gmtime : float -> tm
extern val Unix.time : unit -> float
	  
fun format_date tm =
    (case (#tm_wday/tm tm) of
	 0 => "Sun"
       | 1 => "Mon"
       | 2 => "Tue"
       | 3 => "Wed"
       | 4 => "Thur"
       | 5 => "Fri"
       | 6 => "Sat"
       | _ => raise (Invalid_argument "format_date")
    )
    ^ ", "
    ^ (string_of_int (#tm_mday/tm tm))
    ^	
    (case #tm_mon/tm tm of
	 0 => "January"
       | 1 => "February"
       | 2 => "March"
       | 3 => "April"
       | 4 => "May"
       | 5 => "June"
       | 6 => "July"
       | 7 => "August"
       | 8 => "September"
       | 9 => "October"
       | 10 => "November"
       | 11 => "December"
       | _ => raise (Invalid_argument "format_date")
    )
    ^ (string_of_int ((#tm_year/tm tm) + 1900))
    ^ ":" ^ (string_of_int (#tm_hour/tm tm))
    ^ ":" ^ (string_of_int (#tm_min/tm tm))
    ^ ":" ^ (string_of_int (#tm_sec/tm tm))

fun build_success s =
    "HTTP/1.0 200 OK"
    :: ("Date: " ^
	(format_date (Unix.gmtime (Unix.time ()))))
    :: "Content-Type: text/html"
    :: ("Content-Length: " ^ (string_of_int (String.length s)))
    :: "Connection: Keep-Alive"
    :: ""
    :: s
    :: nil
		
fun build_inv_req () =
    "HTTP/1.0 400 Bad Request" :: nil

fun build_404 () =
    "HTTP/1.0 404 Not Found" :: nil

val dummy_page =
    "<html><head><title>Dummy page</title></head><body>Hi!</body></html>"
(*
fun build_stat_page () =
    let fun build_row {page, views} =
            cat ("<tr><td>", cat (page, cat ("</td><td>", cat(Int.toString views,
            "</td></tr>\n"))))
    in
        cat ("<html><head><title>Server Statistics</title></head>\n",
        cat ("<body>\n",
        cat ("<h1>Server statistics</h1>\n", (* as of " ^
        (Date.fmt "%a, %d %b %Y %H:%M:%S %Z"
                  (Date.fromTimeLocal (Time.now ()))) ^ "</h1>\n" ^ *)
        cat ("<table border=1>\n",
        cat ("<tr><td>Page</td><td>Views</tr>\n",
        cat ((List.foldl cat "" (List.map build_row (!stats))),
        cat ("</table>",
        "</body></html>")))))))
    end

(* Stolen from Tom Murphy VII's StringUtil *)
fun readfile f =
    (let
        val l = TextIO.openIn f
        val s = TextIO.inputAll l
    in
        TextIO.closeIn l; SOME s
    end)
    handle _ => NONE

fun sendLine sock ln =
    (IO.Network.sendString (sock, ln);
     ignore (IO.Network.sendString (sock, "\r\n")))

fun inploop sock =
    let val _ = print "receiving\n"
        val req = (IO.Network.recvString (sock, 1024))
        val _ = print "received\n"
        val _ = print (cat (req, "\n"))
     in
         if eq (String.size req, 0) then
             (Socket.close sock; ())
         else
             let val response =
                 case parse_request req of
                     SOME filename =>
                     (upd (reqbuf, cons (filename, !reqbuf));
                      (* print ("Requested: " ^ filename ^ "\n"); *)
                     if String.isSubstring "stats.html" filename then
                         build_success (build_stat_page ())
                     else
                         (case readfile (cat ("www", filename)) of
                              SOME s => build_success s
                            | NONE => build_404 ()))
                   | NONE => build_inv_req ()
             in
                 print "sending\n";
                 (* print (response ^ "\n"); *)
                 List.app (sendLine sock) response;
                 print "sent\n";
                 Socket.close sock
                 (* inploop sock *)
             end
     end


fun acceptloop sock =
    (let val _ = print "listening\n"
        val (s, _) = (IO.Network.accept sock)
        val _ = addtosocks s
        val _ = print "accepted\n"
     in
         cmd[accept_p]
            {
              spawn[serve_p] { ret (inploop s) };
              acceptloop sock
            }
    end)

main
{
  l <- spawn[accept_p] { acceptloop sock };
  ret (print "spawned\n");
  spawn[stat_p] { statloop () };
  sync l
}
 *)

		main
		{
		 ret 5
		}
